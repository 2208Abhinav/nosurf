package nosurf

import (
	crand "crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"math/rand"
)

var (
	generator   *rand.Rand
	tokenLength = base64.StdEncoding.EncodedLen(sha256.Size)
)

// A token is currently generated by
// taking a pseudo-random int64 (actualy Int63()),
// converting it into a byte slice as uint64,
// and encoding a SHA256 hash of that
// as Base64.

func generateToken() string {
	num := generator.Int63()
	bytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(bytes, uint64(num))

	hash := sha256.New()
	hash.Write(bytes)

	sum := hash.Sum(nil)

	return base64.StdEncoding.EncodeToString(sum)
}

func init() {
	// We create a new PRNG and seed it with an int64 from crypto/rand
	// I guess that's okay for a CSRF token?

	// read 8 bytes from crypto/rand
	bytes := make([]byte, 8)
	n, err := crand.Read(bytes)

	if err != nil {
		panic(err)
	} else if n != 8 {
		panic("crypto/rand didn't give us enough bytes")
	}

	// the endianness probably doesn't matter
	// the same should go for the value got by converting
	// an unsigned int to a signed one
	seed := binary.LittleEndian.Uint64(bytes)

	source := rand.NewSource(int64(seed))
	generator = rand.New(source)
}
